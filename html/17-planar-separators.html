<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>17-planar-separators</title>
  <style>
    html {
      font-size: 18px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 50em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 data-number="1" id="planar-separatorsbeta"><span
class="header-section-number">1</span> Planar Separators<span
class="math inline">\(^\beta\)</span></h1>
<p>Let <span class="math inline">\(\Sigma\)</span> be an arbitrary
planar map, with non-negative weights on its vertices, edges, and/or
faces that sum to <span class="math inline">\(W\)</span>. A simple cycle
<span class="math inline">\(C\)</span> in a planar map <span
class="math inline">\(\Sigma\)</span> is a <em>balanced cycle
separator</em> if the total weight of all vertices, edges, and faces on
either side of <span class="math inline">\(C\)</span> is at most <span
class="math inline">\(3W/4\)</span>. As long as each vertex, edge, or
face of <span class="math inline">\(\Sigma\)</span> has weight at most
<span class="math inline">\(W/4\)</span>, there is a balanced cycle
separator with at most <span class="math inline">\(O(\sqrt{n})\)</span>
vertices; moreover, we can compute such a cycle in <span
class="math inline">\(O(n)\)</span> time.</p>
<h2 data-number="1.1" id="tree-separators"><span
class="header-section-number">1.1</span> Tree separators</h2>
<p>Before we consider separators in planar graphs, let’s consider the
simpler case of trees. Here a balanced separator is a single edge that
splits the tree into two subtrees of roughly equal weight. Tree
separators were first studied by Camille Jordan</p>
<p>Let <span class="math inline">\(T = (V, E)\)</span> be an unrooted
tree in which every vertex has degree at most <span
class="math inline">\(3\)</span>. Intuitively, <span
class="math inline">\(T\)</span> is a “binary” tree, but without a root
and without a distinction between left and right children. (This
bounded-degree assumption is necessary.) Assign each vertex <span
class="math inline">\(v\)</span> a non-negative weight <span
class="math inline">\(w(v)\)</span> and let <span
class="math inline">\(W := \sum_v w(v)\)</span>.</p>
<dl>
<dt><strong>Tree-separator lemma:</strong></dt>
<dd>
<em>If every vertex has weight at most <span
class="math inline">\(W/4\)</span>, there is an edge <span
class="math inline">\(e\)</span> in <span
class="math inline">\(T\)</span> such that the total weight in either
component of <span class="math inline">\(T\setminus e\)</span> is at
most <span class="math inline">\(3W/4\)</span>.</em>
</dd>
<dt><strong>Proof:</strong></dt>
<dd>
Pick an arbitrary leaf <span class="math inline">\(r\)</span> of <span
class="math inline">\(T\)</span> as the root, and direct all edges away
from <span class="math inline">\(r\)</span>, so every vertex in <span
class="math inline">\(T\)</span> has at most two children. By attaching
leaves with weight zero, we can assume without loss of generality that
every non-leaf vertex has exactly two children.
</dd>
<dd>
<p>For any vertex <span class="math inline">\(v\)</span>, let <span
class="math inline">\(W(v)\)</span> denote the total weight of <span
class="math inline">\(v\)</span> and its descendants; for example, <span
class="math inline">\(W(r) = W\)</span>. For any non-leaf vertex <span
class="math inline">\(v\)</span>, label its children <span
class="math inline">\(\textsf{heft}(v)\)</span> and <span
class="math inline">\(\textsf{lite}(v)\)</span> so that <span
class="math inline">\(W(\textsf{heft}(v)) \ge
W(\textsf{lite}(v))\)</span> (breaking ties arbitrarily).</p>
</dd>
<dd>
<p>Starting at the root <span class="math inline">\(r\)</span>, follow
pointers down to the first vertex <span class="math inline">\(x\)</span>
such that <span class="math inline">\(W(\textsf{heft}(x)) \le
W/4\)</span>. Then we immediately have <span class="math display">\[
\begin{aligned}
    W/4 &amp;&lt; W(x)
\\      &amp;= W(\textsf{heft}(x)) + W(\textsf{lite}(x)) + w(x)
\\      &amp;\le 2\cdot W(\textsf{heft}(x)) + w(x)
\\      &amp;\le 3W/4.
\end{aligned}
\]</span> Let <span class="math inline">\(e\)</span> be the edge between
<span class="math inline">\(x\)</span> and its parent. The two
components of <span class="math inline">\(T\setminus e\)</span> have
total weight <span class="math inline">\(W(x) \le 3W-4\)</span> and
<span class="math inline">\(W - W(x) &lt; 3W/4\)</span>. <span
class="math inline">\(\qquad\square\)</span>.</p>
</dd>
</dl>
<p>It’s easy to see that the upper bounds on vertex degree and vertex
weight are both necessary. This separator lemma has several variants;
I’ll mention just a few without proof:</p>
<dl>
<dt><strong>Unweighted tree-separator lemma:</strong></dt>
<dd>
<em>For any <span class="math inline">\(n\)</span>-vertex tree <span
class="math inline">\(T\)</span> with maximum degree <span
class="math inline">\(3\)</span>, there is an edge <span
class="math inline">\(e\)</span> such that the each component of <span
class="math inline">\(T\setminus e\)</span> has at most <span
class="math inline">\(2n/3\)</span> vertices.</em>
</dd>
<dt><strong>Edge-weight tree-separator lemma:</strong></dt>
<dd>
<em>For any tree <span class="math inline">\(T\)</span> with maximum
degree <span class="math inline">\(3\)</span> and any weights on the
<strong>edges</strong> of <span class="math inline">\(T\)</span> that
sum to <span class="math inline">\(W\)</span>, there is an edge <span
class="math inline">\(e\)</span> such that both components of <span
class="math inline">\(T\setminus e\)</span> have total edge weight at
most <span class="math inline">\(2W/3\)</span>.</em>
</dd>
<dt><strong>Vertex tree-separator lemma:</strong></dt>
<dd>
<em>For any tree <span class="math inline">\(T\)</span> and any weights
on the vertices of <span class="math inline">\(T\)</span> that sum to
<span class="math inline">\(W\)</span>, there is a
<strong>vertex</strong> <span class="math inline">\(v\)</span> such that
every component of <span class="math inline">\(T\setminus v\)</span> has
total weight at most <span class="math inline">\(W/2\)</span>.</em>
</dd>
</dl>
<h2 data-number="1.2" id="fundamental-cycle-separators"><span
class="header-section-number">1.2</span> Fundamental cycle
separators</h2>
<p>Now let <span class="math inline">\(\Sigma\)</span> be a planar
<em>triangulation</em>. Assign each face <span
class="math inline">\(f\)</span> a non-negative weight <span
class="math inline">\(w(f) \le W/4\)</span>, where <span
class="math inline">\(W := \sum_f w(f)\)</span>. (Again, the upper
bounds on face degree and face weight are both necessary.) A cycle <span
class="math inline">\(C\)</span> in <span
class="math inline">\(\Sigma\)</span> is a <em>balanced separator</em>
if the total weight on either side of <span
class="math inline">\(C\)</span> is at most <span
class="math inline">\(3W/4\)</span>.</p>
<p>Let <span class="math inline">\(T\)</span> be an arbitrary spanning
tree of <span class="math inline">\(\Sigma\)</span>. For any non-tree
edge <span class="math inline">\(e\)</span>, the <em>fundamental
cycle</em> <span class="math inline">\(\textsf{cycle}(T, e)\)</span> is
the unique cycle in <span class="math inline">\(T+e\)</span>, consisting
of <span class="math inline">\(e\)</span> and the unique path in <span
class="math inline">\(T\)</span> between the endpoints of <span
class="math inline">\(e\)</span>.</p>
<dl>
<dt><strong>Lemma:</strong></dt>
<dd>
<em>At least one fundamental cycle <span
class="math inline">\(\textsf{cycle}(T, e)\)</span> is a balanced
separator for <span class="math inline">\(\Sigma\)</span>.</em>
</dd>
<dt><strong>Proof:</strong></dt>
<dd>
Let <span class="math inline">\(C^*\)</span> be the spanning tree of
<span class="math inline">\(\Sigma^*\)</span> complementary to <span
class="math inline">\(T\)</span>. Because <span
class="math inline">\(\Sigma\)</span> is a triangulation, every vertex
of <span class="math inline">\(C^*\)</span> has degree at most <span
class="math inline">\(3\)</span>. Suppose each vertex of <span
class="math inline">\(C^*\)</span> inherits its weight from the
corresponding face of <span class="math inline">\(\Sigma\)</span>. The
tree-separator lemma implies that there is some edge <span
class="math inline">\(e\)</span> such that each component of <span
class="math inline">\(C^*\setminus e^*\)</span> has at most <span
class="math inline">\(3/4\)</span> the total weight of the vertices of
<span class="math inline">\(C^*\)</span>. It follows that <span
class="math inline">\(\textsf{cycle}(T, e)\)</span> is a balanced
separator. <span class="math inline">\(\qquad\square\)</span>
</dd>
</dl>
<p>We can extend this lemma to the setting where vertices and edges also
have weights, in addition to faces. Let <span
class="math inline">\(w\colon V\cup E\cup F \to \mathbb{R}_+\)</span> be
the given weight function. Define a new face-weight function <span
class="math inline">\(w’\colon F\to\mathbb{R}_+\)</span> by moving the
weight of each vertex and edge to some incident face.</p>
<p>Unfortunately, fundamental cycles can be quite long. For any
particular map <span class="math inline">\(\Sigma\)</span>, we can
minimize the maximum length of all fundamental cycles using a
<em>breadth-first search</em> tree from the correct root vertex as our
spanning tree <span class="math inline">\(T\)</span>, but in the worst
case, every <em>balanced</em> fundamental cycle separator has length
<span class="math inline">\(\Omega(n)\)</span>.</p>
<p>For most applications of balanced separators, breadth-first
fundamental cycles are usually the best choice <em>in practice</em>; see
the detailed experimental analysis by Fox-Epstein et al. [1].</p>
<h2 data-number="1.3" id="breadth-first-level-separators"><span
class="header-section-number">1.3</span> Breadth-first level
separators</h2>
<p>A second easy method for computing separators is to consider the
levels of a breadth-first search tree. For the moment, let’s assume that
the <em>vertices</em> of <span class="math inline">\(\Sigma\)</span> are
weighted. For each integer <span class="math inline">\(\ell\)</span>,
let <span class="math inline">\(V_\ell\)</span> denote the vertices
<span class="math inline">\(\ell\)</span> steps away from the root
vertex of <span class="math inline">\(T\)</span>. By computing a
weighted median, we can find a level <span
class="math inline">\(V_m\)</span> such that the total vertex weight in
any component of <span class="math inline">\(\Sigma\setminus
V_m\)</span> is at most <span class="math inline">\(W/2\)</span>.</p>
<p>There are two obvious problems with this separator construction. The
less serious problem is that the medial level <span
class="math inline">\(V_m\)</span> is not a cycle; it’s just a cloud of
vertices. Many applications of planar separators don’t actually require
<em>cycle</em> separators, but most of the applications we’ll see in
this class do. The more serious problem is size; in the worst case, the
set <span class="math inline">\(V_m\)</span> could contain a constant
fraction of the vertices.</p>
<p>When Richard Lipton and Robert Tarjan introduced planar separators in
1979, they did not consider cycle separators. Rather, they proved that
there is always a subset <span class="math inline">\(S\)</span> of <span
class="math inline">\(O(\sqrt{n})\)</span> vertices such that any
component of <span class="math inline">\(\Sigma\setminus S\)</span> has
at most <span class="math inline">\(2n/3\)</span> vertices. Lipton and
Tarjan’s construction combines fundamental cycle separators and
BFS-level separators. I will not describe their construction in detail,
partly because we really do need cycles, and partly because most of
their ideas show up in the next section.</p>
<h2 data-number="1.4" id="cycle-separators"><span
class="header-section-number">1.4</span> Cycle separators</h2>
<p>Gary Miller was the first to prove that small balanced cycle
separators exist, in 1986. The following refinement of Miller’s
algorithm is based on later proofs by Philip Klein, Shay Mozes, and
Christian Sommer (2013) and Sariel Har-Peled and Amir Nayyeri (2018).
Miller’s key idea was to generalize our notion of “level” from vertices
to faces.<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a></p>
<p>As in our earlier setup, Let <span
class="math inline">\(\Sigma\)</span> be a simple planar triangulation
with weighted faces, where no individual face weight is too large. Let
<span class="math inline">\(T_0\)</span> be a breadth-first search tree,
and suppose the fundamental cycle <span
class="math inline">\(\textsf{cycle}(T_0, xy)\)</span> is a balanced
separator. If this cycle has length <span
class="math inline">\(O(\sqrt{n})\)</span>, we are done, so assume
otherwise.</p>
<p>Let <span class="math inline">\(r\)</span> denote the least common
ancestor of <span class="math inline">\(x\)</span> and <span
class="math inline">\(y\)</span>, and let <span
class="math inline">\(T\)</span> be a breadth-first search tree rooted
at <span class="math inline">\(r\)</span>. The cycle <span
class="math inline">\(\textsf{cycle}(T, xy) = \textsf{cycle}(T_0,
xy)\)</span> is still a balanced separator.</p>
<p>For any vertex <span class="math inline">\(v\)</span>, let <span
class="math inline">\(\textsf{level}(v)\)</span> denote the
breadth-first distance from <span class="math inline">\(r\)</span> to
<span class="math inline">\(v\)</span>. Without loss of generality,
assume <span class="math inline">\(\textsf{level}(x) \le
\textsf{level}(y)\)</span>. Then for any face <span
class="math inline">\(f\)</span>, let <span
class="math inline">\(\textsf{level}(f)\)</span> denote the maximum
level among the three vertices of <span
class="math inline">\(f\)</span>. A face at level <span
class="math inline">\(\ell\)</span> has vertices only at levels <span
class="math inline">\(\ell\)</span> and <span
class="math inline">\(\ell-1\)</span>. Let <span
class="math inline">\(o\)</span> denote the outer face of <span
class="math inline">\(\Sigma\)</span>, and without loss of generality,
assume that <span class="math inline">\(L = \textsf{level}(o) = \max_f
\textsf{level}(f)\)</span>.</p>
<p>For any integer <span class="math inline">\(\ell\)</span>, let <span
class="math inline">\(U_{\le\ell}\)</span> denote the union of all faces
with level at most <span class="math inline">\(\ell\)</span>, and let
<span class="math inline">\(C_\ell\)</span> be the outer boundary of
<span class="math inline">\(U_{\le\ell}\)</span>. Trivially <span
class="math inline">\(U_{\le 0} = \varnothing\)</span> and therefore
<span class="math inline">\(C_0 = \varnothing\)</span>. Similarly, fr
any <span class="math inline">\(\ell\ge L\)</span>, we have <span
class="math inline">\(U_{\le \ell} = \mathbb{R}^2\)</span> and therefore
<span class="math inline">\(C_\ell = \varnothing\)</span>.</p>
<dl>
<dt><strong>Lemma:</strong></dt>
<dd>
<ol type="a">
<li><em>Every vertex in <span class="math inline">\(C_\ell\)</span> has
level <span class="math inline">\(\ell\)</span>.</em></li>
</ol>
</dd>
<dd>
<ol start="2" type="a">
<li><em>Every non-empty subgraph <span
class="math inline">\(C_\ell\)</span> is a simple cycle.</em></li>
</ol>
</dd>
<dd>
<ol start="3" type="a">
<li><em>The cycles <span class="math inline">\(C_\ell\)</span> are
pairwise vertex-disjoint.</em></li>
</ol>
</dd>
<dd>
<ol start="4" type="a">
<li><em>The fundamental cycle <span
class="math inline">\(\textsf{cycle}(T, xy)\)</span> intersects <span
class="math inline">\(C_\ell\)</span> in at most two vertices</em></li>
</ol>
</dd>
<dt><strong>Proof:</strong></dt>
<dd>
Part (a) follows directly from the definitions.
</dd>
<dd>
<p>By construction <span class="math inline">\(C_\ell\)</span> consists
of one or more simple cycles, any two of which share at most one vertex.
Let <span class="math inline">\(C\)</span> be the simple cycle in <span
class="math inline">\(C_\ell\)</span> that contains <span
class="math inline">\(r\)</span> in its interior. and let <span
class="math inline">\(v\)</span> be any vertex of <span
class="math inline">\(C_\ell\setminus C\)</span>. Let <span
class="math inline">\(u\)</span> be the second-to-last vertex on the
shortest path from <span class="math inline">\(r\)</span> to <span
class="math inline">\(v\)</span>. Vertex <span
class="math inline">\(u\)</span> has level <span
class="math inline">\(\ell-1\)</span> and therefore does not lie on
<span class="math inline">\(C\)</span>; moreover, because <span
class="math inline">\(v\not\in C\)</span>, vertex <span
class="math inline">\(u\)</span> cannot lie in the interior of <span
class="math inline">\(C\)</span>. The Jordan curve theorem implies that
the shortest path from <span class="math inline">\(u\)</span> to <span
class="math inline">\(r\)</span> crosses <span
class="math inline">\(C\)</span>, but this is impossible, because levels
decrease monotonically along that path. We conclude that <span
class="math inline">\(C_\ell = C\)</span>, proving part (b).</p>
</dd>
<dd>
<p>Part (c) follows immediately from part (a).</p>
</dd>
<dd>
<p>Finally, the vertices of <span
class="math inline">\(\textsf{cycle}(T, xy)\)</span> lie on two shortest
paths from <span class="math inline">\(r\)</span>, one to <span
class="math inline">\(x\)</span> and the other to <span
class="math inline">\(y\)</span>. Levels increase monotonically along
any shortest path from <span class="math inline">\(r\)</span>. Thus, by
part (a), the shortest paths from <span class="math inline">\(r\)</span>
to <span class="math inline">\(x\)</span> and <span
class="math inline">\(y\)</span> each share at most one vertex with
<span class="math inline">\(C_\ell\)</span>. <span
class="math inline">\(\qquad\square\)</span></p>
</dd>
</dl>
<figure>
<img src="Fig/separator-face-levels.png" style="width:95.0%"
alt="Depth contours in a plane triangulation. The starred vertex is the root r. Faces with even depth are shaded. Cycles C_\ell are black. Green cycles are other portions of the boundary of sublevel sets U_\ell." />
<figcaption aria-hidden="true">Depth contours in a plane triangulation.
The starred vertex is the root <span class="math inline">\(r\)</span>.
Faces with even depth are shaded. Cycles <span
class="math inline">\(C_\ell\)</span> are black. Green cycles are other
portions of the boundary of sublevel sets <span
class="math inline">\(U_\ell\)</span>.</figcaption>
</figure>
<p>Let <span class="math inline">\(m\)</span> be the largest integer
such that the total weight of all faces inside <span
class="math inline">\(C_m\)</span> is at most <span
class="math inline">\(W/2\)</span>. Then the total weight of the faces
<em>outside</em> <span class="math inline">\(C_{m+1}\)</span> is also at
most <span class="math inline">\(W/2\)</span>. If either of these cycles
is a balanced cycle separator of length <span
class="math inline">\(O(\sqrt{n})\)</span>, we are done, so assume
otherwise. We choose two level cycles <span
class="math inline">\(C^-\)</span> and <span
class="math inline">\(C^+\)</span> as follows.<a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<ul>
<li><p>Consider the set of cycles <span
class="math inline">\(\mathcal{C}^- = \{C_\ell \mid m-\sqrt{n} &lt; \ell
\le m\}\)</span>. These <span class="math inline">\(\sqrt{n}\)</span>
cycles contain at most <span class="math inline">\(n\)</span> vertices,
and therefore some cycle <span class="math inline">\(C^-\)</span> in
this set must have length less than <span
class="math inline">\(\sqrt{n}\)</span>. By construction, the total
weight of all faces inside <span class="math inline">\(C^-\)</span> is
at most <span class="math inline">\(W/2\)</span>.</p></li>
<li><p>Similarly, consider the set <span
class="math inline">\(\mathcal{C}^+ = \{C_\ell \mid m &lt; \ell \le m +
\sqrt{n}\}\)</span>. These <span class="math inline">\(\sqrt{n}\)</span>
cycles contain at most <span class="math inline">\(n\)</span> vertices,
and therefore some cycle <span class="math inline">\(C^+\)</span> in
this set must have length less than <span
class="math inline">\(\sqrt{n}\)</span>. By construction, the total
weight of all faces outside <span class="math inline">\(C^+\)</span> is
at most <span class="math inline">\(W/2\)</span>.</p></li>
</ul>
<p>Let <span class="math inline">\(\pi_x\)</span> denote the portion of
the shortest path from <span class="math inline">\(r\)</span> to <span
class="math inline">\(x\)</span> with levels between <span
class="math inline">\(a\)</span> and <span
class="math inline">\(b\)</span>, and define <span
class="math inline">\(\pi_y\)</span> similarly. By construction, each of
these paths has length at most <span
class="math inline">\(2\sqrt{n}\)</span>. Let <span
class="math inline">\(\Theta\)</span> denote the graph <span
class="math inline">\(C^- \cup C^+ \cup \pi_x \cup \pi_y\)</span>, as
shown in the figure below. This subgraph of <span
class="math inline">\(\Theta\)</span> has at most <span
class="math inline">\(4\sqrt{n}\)</span> vertices and edges. We label
the four faces of <span class="math inline">\(\Theta\)</span> as
follows:</p>
<ul>
<li><span class="math inline">\(A\)</span> is the interior of <span
class="math inline">\(C^-\)</span>.</li>
<li><span class="math inline">\(B\)</span> is the exterior of <span
class="math inline">\(C^+\)</span>.</li>
<li><span class="math inline">\(C\)</span> is the region between <span
class="math inline">\(C^+\)</span> and <span
class="math inline">\(C^-\)</span> and outside <span
class="math inline">\(\textsf{cycle}(T, xy)\)</span>.</li>
<li><span class="math inline">\(D\)</span> is the region between <span
class="math inline">\(C^+\)</span> and <span
class="math inline">\(C^-\)</span> and inside <span
class="math inline">\(\textsf{cycle}(T, xy)\)</span>.</li>
</ul>
<figure>
<img src="Fig/cycle-separator.png" style="width:30.0%"
alt="Regions in the cycle-separator algorithm." />
<figcaption aria-hidden="true">Regions in the cycle-separator
algorithm.</figcaption>
</figure>
<p>Let <span class="math inline">\(W(S)\)</span> denote the total weight
of the set of faces <span class="math inline">\(S\)</span>. By
construction we have <span class="math display">\[
    \begin{aligned}
        W(A) &amp; \le W/2, &amp;&amp;&amp;
        W(B) &amp; \le W/2, &amp;&amp;&amp;
        W(C) &amp; \le 3W/4, &amp;&amp;&amp;
        W(D) &amp; \le 3W/4.
    \end{aligned}
\]</span> At least one of these four regions contains total weight at
least <span class="math inline">\(W/4\)</span>; the boundary of that
region is a balanced cycle separator of length <span
class="math inline">\(O(\sqrt{n})\)</span>.</p>
<p>Most divide-and-conquer algorithms that use cycle separators do not
delete the separator vertices to obtain smaller subgraphs. Rather, the
algorithms <em>slice</em> the planar map along the cycle separator to
obtain smaller <em>maps</em>, called <em>pieces</em> of the original
map, one containing the faces inside the cycle and the other containing
the faces outside. Both pieces contain a copy of the <span
class="math inline">\(O(\sqrt{n})\)</span> vertices and edges of the
separator. Thus, the total size of all subproblems is larger at deeper
levels of the recursion tree, but because that increase is sublinear, we
can ignore it when solving the resulting divide-and-conquer
recurrences.</p>
<h2 data-number="1.5"
id="good-r-divisions-and-subdivision-hierarchies"><span
class="header-section-number">1.5</span> Good <span
class="math inline">\(r\)</span>-divisions and Subdivision
Hierarchies</h2>
<p>An <span class="math inline">\(r\)</span>-division is a decomposition
of a planar map into <span class="math inline">\(n/r\)</span>
<em>pieces</em>, each of which has <span
class="math inline">\(O(r)\)</span> vertices and <span
class="math inline">\(O(\sqrt{r})\)</span> boundary vertices (shared
with other pieces). An <span class="math inline">\(r\)</span>-division
is <em>good</em> if each piece is a disk with <span
class="math inline">\(O(1)\)</span> holes. For any <span
class="math inline">\(r\)</span>, we can construct a good <span
class="math inline">\(r\)</span>-division by recursively slicing the
input triangulation along balanced cycle separators. In fact, this
subdivision strategy computes a <em>subdivision hierarchy</em> that
includes good <span class="math inline">\(r\)</span>-divisions for
arbitrary values of <span class="math inline">\(r\)</span>.</p>
<p>In each recursive call, we are given a region <span
class="math inline">\(R\)</span>, which is a connected subcomplex of the
original triangulation <span class="math inline">\(\Sigma\)</span>. Any
face of the region <span class="math inline">\(R\)</span> that is not a
face of <span class="math inline">\(\Sigma\)</span> is called a
<em>hole</em>; any vertex of <span class="math inline">\(R\)</span> that
is incident to a hole is a <em>boundary vertex</em> of <span
class="math inline">\(R\)</span>. To split <span
class="math inline">\(R\)</span> into two smaller regions, we first
triangulate <span class="math inline">\(R\)</span> by inserting an
artificial vertex <span class="math inline">\(v_h\)</span> inside each
hole <span class="math inline">\(h\)</span>, along with artificial edges
connecting <span class="math inline">\(v_h\)</span> to each corner of
<span class="math inline">\(h\)</span>. We then compute a cycle
separator in the resulting triangulation <span
class="math inline">\(R’\)</span>, splitting it into two smaller
triangulated regions <span class="math inline">\(R’_0\)</span> and <span
class="math inline">\(R’_1\)</span>. Finally, we delete the artificial
vertices and edges from <span class="math inline">\(R’_0\)</span> and
<span class="math inline">\(R’_1\)</span> to get the final regions <span
class="math inline">\(R_0\)</span> and <span
class="math inline">\(R_1\)</span>.</p>
<figure>
<img src="Fig/recursive-decomposition.png" style="width:95.0%"
alt="A region with three holes, a cycle separator for the triangulated region, and the resulting smaller regions." />
<figcaption aria-hidden="true">A region with three holes, a cycle
separator for the triangulated region, and the resulting smaller
regions.</figcaption>
</figure>
<p>To simultaneously bound the number of vertices, the number of
boundary vertices, and the number of holes in the final regions, we
cycle through three different vertex weights at different levels of
recursion. Specifically, at recursion depth <span
class="math inline">\(l\)</span>, we weight the vertices as follows:</p>
<ul>
<li>If <span class="math inline">\(l\bmod 3 = 0\)</span>, we give
natural vertices weight <span class="math inline">\(1\)</span> and
artificial vertices weight <span class="math inline">\(0\)</span>, so
that the separator splits natural vertices evenly.</li>
<li>If <span class="math inline">\(l\bmod 3 = 1\)</span>, we give
boundary vertices weight <span class="math inline">\(1\)</span> and all
other vertices weight <span class="math inline">\(0\)</span>, so that
the separator splits boundary vertices evenly.</li>
<li>If <span class="math inline">\(l\bmod 3 = 2\)</span>, we give
artificial vertices weight <span class="math inline">\(1\)</span> and
natural vertices weight <span class="math inline">\(0\)</span>, so that
the separator splits holes evenly.</li>
</ul>
<p>Let <span class="math inline">\(T_r(n, b, h)\)</span> denote the time
to compute a good <span class="math inline">\(r\)</span>-division for a
region with <span class="math inline">\(n\)</span> vertices, <span
class="math inline">\(b\)</span> boundary vertices, and <span
class="math inline">\(h\)</span> holes. Expanding out three levels of
recursion, we have <span class="math display">\[
    T_r(n, b, h)
    =
    O(n + h) + \sum_{i=1}^8 T_r(n_i, b_i, h_i),
\]</span> where <span class="math display">\[
    \begin{aligned}
        \sum_{i=1}^8 n_i &amp;\le n + O(\sqrt{n})
        &amp; \sum_{i=1}^8 b_i &amp;\le b + O(\sqrt{n})
        &amp; \sum_{i=1}^8 h_i &amp;\le h + O(1)
        \\
        \max_i n_i &amp;\le 3n/4 + O(\sqrt{n})
        &amp; \max_i b_i &amp;\le 3b/4 + O(\sqrt{n})
        &amp; \max_i h_i &amp;\le 3h/4 + O(1)
    \end{aligned}
\]</span> for suitable absolute big-Oh constants. The recursion stops
when the number of vertices in each piece is <span
class="math inline">\(O(r)\)</span>. Every leaf in the recursion tree
has depth at most <span class="math inline">\(O(\log (n/r))\)</span>,
and there are at most <span class="math inline">\(O(n/r)\)</span> such
leaves. One can prove by induction that in every recursive subproblem,
the number of boundary vertices is at most <span
class="math inline">\(O(\sqrt{r})\)</span> and the number of holes is at
most <span class="math inline">\(O(1)\)</span>, so we end with a good
<span class="math inline">\(r\)</span>-division. We perform <span
class="math inline">\(O(n)\)</span> work at every level of recursion, so
the overall running time of the algorithm is <span
class="math inline">\(T_r(n, 0, 0) = O(n \log(n/r))\)</span>. In
particular, if <span class="math inline">\(r = O(1)\)</span>, the entire
algorithm runs in <span class="math inline">\(O(n\log n)\)</span>
time.</p>
<p><strong>Theorem:</strong> <em>Given a planar triangulation <span
class="math inline">\(\Sigma\)</span> with <span
class="math inline">\(n\)</span> vertices, we can compute a recursive
subdivision of <span class="math inline">\(\Sigma\)</span>, containing
good <span class="math inline">\(r\)</span>-divisions of <span
class="math inline">\(\Sigma\)</span> for every <span
class="math inline">\(r \ge r_0\)</span>, in <span
class="math inline">\(O(n \log (n/r_0))\)</span> time.</em></p>
<p><strong>Corollary:</strong> <em>Given a planar triangulation <span
class="math inline">\(\Sigma\)</span> with <span
class="math inline">\(n\)</span> vertices and an integer <span
class="math inline">\(r\)</span>, we can compute a good <span
class="math inline">\(r\)</span>-division of <span
class="math inline">\(\Sigma\)</span> in <span class="math inline">\(O(n
\log (n/r))\)</span> time.</em></p>
<p>Some applications of separators actually require a nested sequence of
good <span class="math inline">\(r\)</span>-divisions with exponentially
decreasing values of <span class="math inline">\(r\)</span>. For any
vector <span class="math inline">\(\vec{r} = (r_1, r_2, \dots,
r_t)\)</span> where <span class="math inline">\(r_i &lt;
r_{i-1}/\alpha\)</span> for some suitable constant <span
class="math inline">\(\alpha\)</span>, a <em>good <span
class="math inline">\(\vec{r}\)</span>-division</em> of a planar map
<span class="math inline">\(\Sigma\)</span> consists of a good <span
class="math inline">\(r_1\)</span>-division <span
class="math inline">\(\mathcal{R}_1\)</span> of <span
class="math inline">\(\Sigma\)</span> and (unless <span
class="math inline">\(t=1\)</span>) a good <span
class="math inline">\((r_2, \dots, r_t)\)</span>-division of each piece
of <span class="math inline">\(\mathcal{R}_1\)</span>. We can easily
extract a good <span class="math inline">\(\vec{r}\)</span>-division
from any good subdivision hierarchy in <span
class="math inline">\(O(n)\)</span> time.</p>
<p><strong>Corollary:</strong> <em>Given a planar triangulation <span
class="math inline">\(\Sigma\)</span> with <span
class="math inline">\(n\)</span> vertices, and any exponentially
decreasing vector <span class="math inline">\(\vec{r} = (r_1, r_2,
\dots, r_t)\)</span>, we can construct a good <span
class="math inline">\(\vec{r}\)</span>-division of <span
class="math inline">\(\Sigma\)</span> in <span class="math inline">\(O(n
\log (n/r_t))\)</span> time.</em></p>
<h2 data-number="1.6" id="history"><span
class="header-section-number">1.6</span> History</h2>
<p>Greg Frederickson introduced <span
class="math inline">\(r\)</span>-divisions (based on non-cycle
separators) in 1989. The current definition of good <span
class="math inline">\(r\)</span>-division was proposed by Philip Klein
and Sairam Subramanian in 1998. The three-phase algorithm I’ve just
described was first proposed by Jittat Fakcharoenphol and Satish Rao in
2006, and extended to <span
class="math inline">\(\vec{r}\)</span>-divisions by Philip Klein, Shay
Mozes, and Christian Sommer in 2013.</p>
<p>This is not the fastest algorithm known for computing good <span
class="math inline">\(r\)</span>-divisions. A different algorithm for
constructing a good <span class="math inline">\(r\)</span>-division in
<span class="math inline">\(O(n\log r + O(n/\sqrt{r})\log n)\)</span>
time was described by Giuseppe Italiano, Yahav Nussbaum, Piotr
Sankowski, and Christian Wulff-Nilsen in 2011.</p>
<p>In 1996, Lyudmil Aleksandrov and Hristo Djidjev described an <span
class="math inline">\(O(n)\)</span>-time algorithm to construct <span
class="math inline">\(r\)</span>-divisions based on Lipton-Tarjan
separators, for any given <span class="math inline">\(r\)</span>. In
2013, Lars Arge, Freek van Walderveen, and Norbert Zeh described an
algorithm to construct a single <em>good</em> <span
class="math inline">\(r\)</span>-division in <span
class="math inline">\(O(n)\)</span> time. <strong><em>[[[How do these
algorithms work?]]]</em></strong></p>
<p>The first linear-time algorithm for building a subdivision
<em>hierarchy</em> containing <span
class="math inline">\(r\)</span>-divisions for every <span
class="math inline">\(r\)</span> was described by Michael Goodrich in
1996. Klein, Mozes, and Sommer described a similar algorithm to compute
a <em>good</em> subdivision hierarchy in <span
class="math inline">\(O(n)\)</span> time.<a href="#fn3"
class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>
Both of these algorithms use dynamic forest data structures (to maintain
tree-cotree decompositions of the pieces, identify fundamental cycle
separators, compute least common ancestors, and compute the weight
enclosed by short cycles), along with several other data structures.</p>
<!--
These algorithms find each separator in the hierarchy in only $O(\sqrt{r}\log^2 r)$ time; the overall running time is dominated by the time to build the initial tree-cotree decomposition, compute levels for vertices or faces of the input triangulation, and initialize the data structures.
-->
<p>In the next lecture we’ll see how to use good <span
class="math inline">\(r\)</span>-divisions to compute shortest paths
quickly.</p>
<h2 data-number="1.7" id="references"><span
class="header-section-number">1.7</span> References</h2>
<ol type="1">
<li><p>Lyudmil Aleksandrov and Hristo Djidjev. <a
href="https://doi.org/10.1137/S0895480194272183">Linear algorithms for
partitioning embedded graphs of bounded genus</a>. <em>SIAM J. Discrete
Math.</em> 9(1):129–150, 1996.</p></li>
<li><p>Lars Arge, Freek van Walderveen, and Norbert Zeh. <a
href="http://doi.org/10.1137/1.9781611973105.65">Multiway simple cycle
separators and {I/O}-efficient algorithms for planar graphs</a>.
<em>Proc. 24th Ann. ACM-SIAM Symp. Discrete Algorithms</em>, 901–918,
2013. <!--
1. Sergio Cabello. [Many distances in planar graphs](https://dl.acm.org/doi/10.5555/1109557.1109691). _Proc. 17th Ann. ACM-SIAM Symp. Discrete Algorithms_, 1213–1220, 2006.

1. Sergio Cabello. [Many distances in planar graphs](https://10.1007/s00453-010-9459-0). _Algorithmica_ 62(1–2):361–381, 2010.
--></p></li>
<li><p>Jittat Fakcharoenphol and Satish Rao. <a
href="https://doi.org/10.1016/j.jcss.2005.05.007">Planar graphs,
negative weight edges, shortest paths, and near linear time</a>. <em>J.
Comput. Syst. Sci.</em> 72(5):868–889, 2006.</p></li>
<li><p>Eli Fox-Epstein, Shay Mozes, Phitchaya Mangpo Phothilimthana, and
Christian Sommer. <a href="https://doi.org/10.1145/2957318">Short and
simple cycle separators in planar graphs</a>. <em>ACM
J. Exp. Algorithmics</em> 21(1):2.2:1–2.2:24, 2016.</p></li>
<li><p>Greg N. Frederickson. <a
href="https://doi.org/10.1137/0216064">Fast algorithms for shortest
paths in planar graphs with applications</a>. <em>SIAM J. Comput.</em>
16(8):1004–1004, 1987.</p></li>
<li><p>Michael T. Goodrich. <a
href="https://doi.org/10.1006/jcss.1995.1076">Planar separators and
parallel polygon triangulation</a>. <em>J. Comput. Syst. Sci.</em>
51(3):374–389, 1995.</p></li>
<li><p>Sariel Har-Peled and Amir Nayyeri. <a
href="https://doi.org/10.48550/arXiv.1709.08122">A simple algorithm for
computing a cycle separator</a>. Preprint, September 2017.
arXiv:1709.08122.</p></li>
<li><p>Giuseppe F. Italiano, Yahav Nussbaum, Piotr Sankowski, and
Christian Wulff-Nilsen. <a
href="https://doi.org/10.1145/1993636.1993679">Improved algorithms for
min cut and max flow in undirected planar graphs</a>. <em>Proc. 43rd
Ann. ACM Symp. Theory Comput.</em>, 313–322, 2011.</p></li>
<li><p>Camille Jordan. <a href="http://eudml.org/doc/148084">Sur les
assemblages de lignes</a>. <em>J. Reine Angew. Math.</em> 70:185–190,
1869.</p></li>
<li><p>Philip N. Klein, Shay Mozes, and Christian Sommer. <a
href="https://doi.org/10.1145/2488608.2488672">Structured recursive
separator decompositions for planar graphs in linear time</a>. <em>Proc.
45th Ann. ACM Symp. Theory Comput.</em>, 505–514, 2013. arXiv:<a
href="https://arxiv.org/abs/1208.2223">1208.2223</a>.</p></li>
<li><p>Philip N. Klein and Sairam Subramanian. <a
href="https://doi.org/10.1007/PL00009223">A fully dynamic approximation
scheme for shortest paths in planar graphs</a>. <em>Algorithmica</em>
22(3):235–249, 1998.</p></li>
<li><p>Richard J. Lipton and Robert E. Tarjan. <a
href="https://doi.org/10.1137/0136016">A separator theorem for planar
graphs</a>. <em>SIAM J. Applied Math.</em> 36(2):177–189, 1979.</p></li>
<li><p>Richard J. Lipton and Robert Endre Tarjan. <a
href="https://doi.org/10.1137/0209046">Applications of a planar
separator theorem</a>. <em>SIAM J. Comput.</em> 9:615–627,
1980.</p></li>
<li><p>Gary L. Miller. <a
href="https://doi.org/10.1016/0022-0000(86)90030-9">Finding small simple
cycle separators for 2-connected planar graphs</a>. <em>J. Comput.
System Sci.</em> 32(3):265–279, 1986.</p></li>
</ol>
<h2 data-number="1.8" id="aptly-named-sir-not"><span
class="header-section-number">1.8</span> Aptly Named Sir Not</h2>
<ul>
<li>Cycle separators via Koebe-Andreev circle packing</li>
<li>Details of <span class="math inline">\(r\)</span> divisions (and
recursive <span class="math inline">\(r\)</span>-divisions) in <span
class="math inline">\(O(n)\)</span> time.</li>
</ul>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Fox-Eppstein et al. [1] describe an arguably simpler
algorithm that uses a dual breadth-first search tree rooted at the outer
face to define face levels, instead of a primal breadth-first search
tree.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>I am ignoring two extreme cases. First, if <span
class="math inline">\(m &lt; \sqrt{n}\)</span>, we define <span
class="math inline">\(C^- = \varnothing\)</span>; similarly, if <span
class="math inline">\(m &gt; \textsf{level}(y) - \sqrt{n}\)</span>, we
define <span class="math inline">\(C^+ = \varnothing\)</span>. Handling
these special cases in the rest of the construction is
straightforward.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>The two 1996 results are completely independent; so are
the two 2013 results.<a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
